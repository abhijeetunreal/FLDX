<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FLDX - PRECISION IN MOTION</title>
    <style>
        html, body { height: 100%; }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: #050505; }
        
        /* viewport/inner wrapper preserves a fixed desktop aspect ratio and centers the inner content */
        #viewport { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; background: #050505; }
        #viewport-inner { position: relative; width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: hidden; }
        #scene-container { position: absolute; left: 0; top: 0; width: 100%; height: 100%; }
        canvas { display: block; width: 100%; height: 100%; } 

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; transform-origin: left top; }
        
        /* CONTROLS PANEL */
        #controls {
            position: absolute; top: 20px; left: 20px; width: 300px;
            background: rgba(10, 10, 10, 0.9); color: #ddd; padding: 20px;
            border-radius: 8px; pointer-events: auto; backdrop-filter: blur(8px);
            border: 1px solid #333; box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            max-height: 90vh; overflow-y: auto;
        }

        /* PHYSICS PANEL */
        #physics-panel {
            position: absolute; top: 20px; right: 20px; width: 260px;
            background: rgba(10, 20, 30, 0.95); color: #88ccff; padding: 15px;
            border-radius: 8px; pointer-events: auto; backdrop-filter: blur(8px);
            border: 1px solid #004466; box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            font-family: 'Consolas', monospace; font-size: 0.85rem;
            max-height: 90vh; overflow-y: auto;
        }

        h2 { margin: 0 0 15px 0; color: #ff9100; font-size: 1.1rem; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        h3 { font-size: 0.9rem; color: #888; margin: 15px 0 5px 0; text-transform: uppercase; display: flex; justify-content: space-between; align-items: center; }
        h4 { margin: 0 0 10px 0; color: #00aaff; border-bottom: 1px solid #004466; padding-bottom: 5px; font-size: 1rem; }

        .control-group { margin-bottom: 12px; }
        .phy-group { margin-bottom: 8px; border-bottom: 1px dashed #335566; padding-bottom: 8px; }
        
        label { display: block; font-size: 0.85rem; margin-bottom: 4px; color: #bbb; }
        .phy-label { color: #88ccff; display: flex; justify-content: space-between; }
        
        /* Range Inputs Style */
        .range-row { display: flex; align-items: center; justify-content: space-between; gap: 5px; margin-bottom: 5px; }
        .limit-input { 
            width: 60px; background: #222; border: 1px solid #444; color: #fff; 
            padding: 4px; border-radius: 4px; text-align: center; font-family: monospace; font-size: 0.9rem;
        }
        .range-sep { color: #666; font-size: 0.8rem; }

        input[type=range] { width: 100%; cursor: pointer; accent-color: #ff9100; height: 4px; margin-top: 2px; }
        select { width: 100%; padding: 6px; background: #222; color: white; border: 1px solid #444; border-radius: 4px; font-size: 0.9rem; }
        
        /* Player Toggle */
        .mode-toggle {
            background: #1a2a3a; padding: 10px; border-radius: 4px; border: 1px solid #2a4a6a; margin-bottom: 15px;
        }
        .mode-row { display: flex; justify-content: space-between; align-items: center; }
        .mode-toggle span { color: #00aaff; font-weight: bold; font-size: 0.9rem; }
        .mode-toggle input[type=checkbox] { width: auto; height: auto; margin: 0; cursor: pointer; transform: scale(1.2); }

        /* Reset Button Style */
        .reset-icon {
            background: transparent; border: 1px solid #555; color: #888; 
            border-radius: 3px; width: 18px; height: 18px; font-size: 10px; line-height: 10px;
            cursor: pointer; margin-left: 8px; padding: 0; display: flex; align-items: center; justify-content: center;
        }
        .reset-icon:hover { border-color: #fff; color: #fff; background: #333; }
        .val-container { display: flex; align-items: center; }

        button.main-btn {
            width: 100%; padding: 12px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; margin-top: 10px; text-transform: uppercase; font-size: 14px;
        }
        #fire-btn { background: linear-gradient(180deg, #d32f2f, #b71c1c); color: white; }
        #fire-btn:hover { filter: brightness(1.1); }
        #reset-phy-btn { background: #004466; color: #00aaff; border: 1px solid #006699; margin-top: 15px; }
        #reset-phy-btn:hover { background: #005580; color: white; }

        /* TELEMETRY OVERLAY */
        #telemetry-bar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); color: #0f0; padding: 10px 20px;
            border-radius: 20px; font-family: 'Consolas', monospace; font-size: 1rem;
            border: 1px solid #333; pointer-events: none; display: flex; gap: 20px;
        }
        
        .ball-label {
            font-family: 'Consolas', monospace; font-size: 11px;
            color: #ffff00; text-shadow: 1px 1px 2px black;
            pointer-events: none; white-space: nowrap;
            background: rgba(0,0,0,0.45); padding: 2px 6px; border-radius: 3px;
            opacity: 0.3; /* slightly lowered to let the ball show through */
            transform-origin: center bottom; /* helps us keep it visually stable */
        }
        .label-row { display: flex; justify-content: space-between; align-items: center; }
        /* LIVE GRAPH PANEL */
        #graph-panel { position: absolute; right: 20px; bottom: 100px; width: 440px; height: 220px; background: rgba(0,0,0,0.6); border-radius: 8px; padding: 10px; display: none; pointer-events: auto; z-index: 30; border: 1px solid #334455; }
        #graph-panel .graph-drag-handle { position: absolute; top: 0; left: 0; right: 0; height: 28px; cursor: move; }
        #graph-panel .graph-resizer { position: absolute; bottom: 6px; right: 6px; width: 16px; height: 16px; background: rgba(255,255,255,0.06); border-radius: 3px; cursor: se-resize; z-index: 35; }
        #graph-panel canvas { width: 100%; height: 100%; display: block; }
        #graph-legend { position: absolute; top: 6px; left: 8px; font-family: monospace; font-size: 11px; color: #cde; /* pointer-events: none; */ display: flex; gap: 12px; align-items: center; }
        #graph-legend .legend-list { display:flex; gap:8px; align-items:center; }
        #graph-legend .legend-item { display:flex; gap:6px; align-items:center; color:#cde; }
        #graph-legend .legend-swatch { width:12px; height:12px; border-radius:2px; display:inline-block; }
        #graph-legend .legend-live { margin-left:12px; font-weight:bold; color:#fff; }

        /* SPLASH SCREEN */
        #splash-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease-out;
        }
        #splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #splash-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }
        #splash-image {
            max-width: 400px;
            width: 100%;
            height: auto;
            margin: 0 auto 30px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        #splash-description {
            color: #ddd;
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 40px;
            padding: 0 20px;
        }
        #start-simulator-btn {
            background: linear-gradient(180deg, #ff9100, #ff6600);
            color: white;
            border: none;
            padding: 16px 48px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 16px rgba(255, 145, 0, 0.3);
            transition: all 0.3s ease;
        }
        #start-simulator-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 145, 0, 0.5);
            filter: brightness(1.1);
        }
        #start-simulator-btn:active {
            transform: translateY(0);
        }
        #desktop-note {
            color: #888;
            font-size: 0.85rem;
            margin-top: 20px;
            opacity: 0.6;
        }
        #main-viewport {
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }
        #main-viewport.visible {
            opacity: 1;
        }

        /* Small device styles */
        @media (max-width: 768px) {
            #splash-content {
                padding: 20px;
                max-width: 90%;
            }
            #splash-image {
                max-width: 280px;
                margin-bottom: 20px;
            }
            #splash-description {
                font-size: 0.9rem;
                line-height: 1.5;
                margin-bottom: 30px;
                padding: 0 10px;
            }
            #start-simulator-btn {
                padding: 12px 32px;
                font-size: 0.95rem;
            }
            #desktop-note {
                font-size: 0.75rem;
                margin-top: 15px;
            }
        }
        @media (max-width: 480px) {
            #splash-content {
                padding: 15px;
            }
            #splash-image {
                max-width: 240px;
                margin-bottom: 15px;
            }
            #splash-description {
                font-size: 0.8rem;
                margin-bottom: 25px;
            }
            #start-simulator-btn {
                padding: 10px 24px;
                font-size: 0.85rem;
            }
            #desktop-note {
                font-size: 0.7rem;
                margin-top: 12px;
            }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splash-screen">
        <div id="splash-content">
            <img id="splash-image" src="Assets/fldx_thumbnail.png" alt="FLDX Simulator">
            <p id="splash-description">
                FLDX is a cricket fielding device simulator that provides precision training drills modelling through realistic physics-based ball projection. 
                Design various fielding drills including high catches, ground fielding, slip catches, and boundary riding. 
                Customize machine parameters, adjust physics properties, and track ball trajectory in real-time.
            </p>
            <button id="start-simulator-btn">Start Simulator</button>
            <p id="desktop-note">Use on desktop for better experience</p>
        </div>
    </div>

    <!-- Main Simulator View -->
    <div id="main-viewport">
    <div id="viewport"><div id="viewport-inner">
        <div id="scene-container"></div>

        <div id="ui-layer">
        <div id="controls">
            <h2>FLDX</h2>
            
            <div class="mode-toggle">
                <div class="mode-row">
                    <span>Simulate Player</span>
                    <input type="checkbox" id="player-mode-toggle">
                </div>
                <div class="control-group" style="margin-top: 8px; border-top: 1px solid #2a4a6a; padding-top: 8px; border-bottom: none; margin-bottom: 0;">
                    <div class="label-row"><span>Error / Variation</span> <span id="val-error">5.0</span></div>
                    <input type="range" id="inp-error" min="0" max="20" step="0.5" value="5.0">
                </div>
            </div>

            <h3>Drill Selection <button class="reset-icon" id="btn-reset-drill" title="Reset Drill Defaults">âŸ³</button></h3>
            <div class="control-group">
                <select id="drill-select">
                    <option value="Manual">Manual Aim</option>
                    <option value="High Catch">High Catch Drill</option>
                    <option value="Grounder">Ground Fielding</option>
                    <option value="Slip Catch">Slip Catch</option>
                    <option value="Boundary">Boundary Riding</option>
                    <option value="Custom">Custom</option>
                </select>
            </div>
            <div class="control-group">
                <select id="env-select">
                    <option value="standard">Standard Pitch</option>
                    <option value="green">Green Top (Bouncy)</option>
                    <option value="dust">Dust Bowl (Dead)</option>
                    <option value="wet">Wet Outfield (Skid)</option>
                </select>
            </div>

            <h3>Machine Ranges</h3>
            
            <div class="control-group">
                <div class="label-row">
                    <span>Speed (km/h)</span> 
                    <span id="val-speed" style="color:#ff9100">80</span>
                </div>
                <input type="range" id="inp-speed" min="40" max="160" value="80" disabled>
                <div class="range-row">
                    <input type="number" id="min-speed" class="limit-input" value="40">
                    <span class="range-sep">to</span>
                    <input type="number" id="max-speed" class="limit-input" value="160">
                </div>
            </div>

            <div class="control-group">
                <div class="label-row">
                    <span>Tilt (Vert Â°)</span> 
                    <span id="val-tilt" style="color:#ff9100">10</span>
                </div>
                <input type="range" id="inp-tilt" min="-10" max="80" value="10" disabled>
                <div class="range-row">
                    <input type="number" id="min-tilt" class="limit-input" value="-10">
                    <span class="range-sep">to</span>
                    <input type="number" id="max-tilt" class="limit-input" value="70">
                </div>
            </div>

            <div class="control-group">
                <div class="label-row">
                    <span>Pan (Horz Â°)</span> 
                    <span id="val-pan" style="color:#ff9100">0</span>
                </div>
                <input type="range" id="inp-pan" min="-45" max="45" value="0" disabled>
                <div class="range-row">
                    <input type="number" id="min-pan" class="limit-input" value="-45">
                    <span class="range-sep">to</span>
                    <input type="number" id="max-pan" class="limit-input" value="45">
                </div>
            </div>

            <div class="control-group">
                <div class="label-row">
                    <span>Release Height</span> <span id="val-height">1.3 m</span>
                </div>
                <input type="range" id="inp-height" min="0.5" max="3.0" step="0.1" value="1.3">
            </div>

            <button id="fire-btn" class="main-btn">FIRE (SPACE)</button>
            <div style="display:flex; gap:8px; margin-top:10px;">
                <button id="btn-toggle-graph" class="reset-icon" title="Toggle Mechanics Graph">ðŸ“ˆ</button>
                <button id="btn-clear-graphs" class="reset-icon" title="Clear Graph Data">âœ–</button>
            </div>
        </div>

        <div id="physics-panel">
            <h4>Physics Override</h4>
            <div class="phy-group"><label class="phy-label"><span>Gravity Y</span> <span id="disp-gravity">-9.81</span></label><input type="range" class="phy-range" id="phy-gravity" min="-20" max="-1" step="0.1" value="-9.81"></div>
            <div class="phy-group"><label class="phy-label"><span>Ball Mass</span> <span id="disp-mass">0.16</span></label><input type="range" class="phy-range" id="phy-mass" min="0.05" max="1.0" step="0.01" value="0.16"></div>
            <div class="phy-group"><label class="phy-label"><span>Air Drag</span> <span id="disp-drag">0.2</span></label><input type="range" class="phy-range" id="phy-drag" min="0" max="1" step="0.05" value="0.3"></div>
            <div class="phy-group"><label class="phy-label"><span>Roll Resist</span> <span id="disp-ang">0.4</span></label><input type="range" class="phy-range" id="phy-ang" min="0" max="1" step="0.05" value="0.4"></div>
            <div class="phy-group" style="border:none; margin-top:10px;">
                <strong style="color:#fff; display:block; margin-bottom:5px;">Pitch Properties</strong>
                <label class="phy-label"><span>Bounce</span> <span id="disp-pres">0.7</span></label><input type="range" class="phy-range" id="phy-pres" min="0" max="1.0" step="0.05" value="0.7">
                <label class="phy-label"><span>Friction</span> <span id="disp-pfric">0.1</span></label><input type="range" class="phy-range" id="phy-pfric" min="0" max="1" step="0.05" value="0.1">
            </div>
            <div class="phy-group" style="border:none;">
                <strong style="color:#fff; display:block; margin-bottom:5px;">Grass Properties</strong>
                <label class="phy-label"><span>Bounce</span> <span id="disp-gres">0.3</span></label><input type="range" class="phy-range" id="phy-gres" min="0" max="1.0" step="0.05" value="0.3">
                <label class="phy-label"><span>Friction</span> <span id="disp-gfric">0.5</span></label><input type="range" class="phy-range" id="phy-gfric" min="0" max="1" step="0.05" value="0.5">
            </div>
            <button id="reset-phy-btn" class="main-btn">Reset Physics</button>
        </div>

        <div id="telemetry-bar">
            <span>V: <span id="stat-vel">--</span></span>
            <span>D: <span id="stat-dist">--</span></span>
            <span>H: <span id="stat-height">--</span></span>
            <span id="stat-status" style="color:#888">Ready</span>
        </div>
        <div id="graph-panel">
            <div class="graph-drag-handle" title="Drag graph panel"></div>
            <div id="graph-legend"></div>
            <canvas id="graph-canvas" width="880" height="440"></canvas>
            <div class="graph-resizer" title="Resize graph panel"></div>
        </div>
    </div>
    </div></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import * as CANNON from 'cannon-es';

        // --- DEFAULT CONFIGS ---
        const defaultDrills = {
            'Manual':       { sMin: 40, sMax: 160, sDef: 80, tMin: -10, tMax: 70, tDef: 10, pMin: -45, pMax: 45, pDef: 0 },
            'High Catch':   { sMin: 75, sMax: 95,  sDef: 85, tMin: 50,  tMax: 70, tDef: 60, pMin: -30, pMax: 30, pDef: 0 },
            'Grounder':     { sMin: 110, sMax: 140, sDef: 125, tMin: -4,  tMax: 2,  tDef: -2, pMin: -20, pMax: 20, pDef: 0 },
            'Slip Catch':   { sMin: 130, sMax: 150, sDef: 140, tMin: 0,   tMax: 10, tDef: 5,  pMin: 15,  pMax: 30, pDef: 22 },
            'Boundary':     { sMin: 90, sMax: 110, sDef: 100, tMin: 25,  tMax: 35, tDef: 30, pMin: -40, pMax: 40, pDef: 0 }
        };

        // --- GLOBAL STATE ---
        const state = {
            pan: 0, tilt: 10, speed: 80, height: 1.3,
            drill: 'Manual', env: 'standard',
            playerMode: false, error: 5.0, 
            limits: { ...defaultDrills['Manual'] },
            
            // v5.1 PHYSICS
            gravity: -9.81, mass: 0.16, drag: 0.3, angDrag: 0.4,
            pRes: 0.7, pFric: 0.1, gRes: 0.3, gFric: 0.5
        };

        const envPresets = {
            standard: { pRes: 0.7, pFric: 0.1, gRes: 0.3, gFric: 0.5 },
            green:    { pRes: 0.85, pFric: 0.2, gRes: 0.2, gFric: 0.8 },
            dust:     { pRes: 0.4, pFric: 0.4, gRes: 0.1, gFric: 0.4 },
            wet:      { pRes: 0.6, pFric: 0.05, gRes: 0.1, gFric: 0.9 }
        };

        let scene, camera, renderer, labelRenderer, world;
        let DESKTOP_ASPECT; // captured on init() to preserve desktop aspect ratio on other screens
        let DESKTOP_WIDTH, DESKTOP_HEIGHT; // capture desktop size so we can scale UI
        const DEFAULT_DESKTOP = { w: 1366, h: 768 }; // fallback preset when the page is loaded on a small device
        let balls = [];
        let graphPanel, graphCanvas, graphCtx, graphVisible = false;
        let lastGraphData = null; // persistent data after ball removal until next fire
        const GRAPH_MAX_SECONDS = 15; // show last 20 seconds in graph
        let matGround, matPitch, matBall, contactGrass, contactPitch;
        let machineBase, machineHead, machineRod, machineSwivel;
        let grassMesh, playerMarker; 
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function resizeViewport() {
            const vpInner = document.getElementById('viewport-inner');
            if (!vpInner || !renderer || !camera) return;
            const vw = window.innerWidth; const vh = window.innerHeight;
            const aspect = DESKTOP_ASPECT || (vw / vh);
            let targetW = vw; let targetH = Math.round(targetW / aspect);
            if (targetH > vh) { targetH = vh; targetW = Math.round(targetH * aspect); }
            vpInner.style.width = targetW + 'px'; vpInner.style.height = targetH + 'px';
            renderer.setSize(targetW, targetH);
            camera.aspect = targetW / targetH; camera.updateProjectionMatrix();
            if (labelRenderer) labelRenderer.setSize(targetW, targetH);
        }

        // Update UI scaling based on DESKTOP_* ratio and current viewport size
        function updateUiScale() {
            try {
                const vpInner = document.getElementById('viewport-inner');
                const uiLayer = document.getElementById('ui-layer');
                if (!vpInner || !uiLayer) return;
                const rect = vpInner.getBoundingClientRect();
                const scaleW = rect.width / (DESKTOP_WIDTH || rect.width);
                const scaleH = rect.height / (DESKTOP_HEIGHT || rect.height);
                const scale = Math.min(scaleW, scaleH);
                uiLayer.style.width = (DESKTOP_WIDTH || rect.width) + 'px';
                uiLayer.style.height = (DESKTOP_HEIGHT || rect.height) + 'px';
                uiLayer.style.transformOrigin = 'left top';
                uiLayer.style.transform = 'scale(' + scale + ')';
                // After UI scale change, ensure panels remain in viewport bounds and the graph canvas is sized
                if (graphPanel) clampPanelToWindow();
                if (graphCanvas) resizeGraphCanvas();
            } catch (e) { console.warn('updateUiScale error', e); }
        }

        // Splash screen handler
        function initSplashScreen() {
            const splashScreen = document.getElementById('splash-screen');
            const mainViewport = document.getElementById('main-viewport');
            const startBtn = document.getElementById('start-simulator-btn');
            
            startBtn.addEventListener('click', () => {
                splashScreen.classList.add('hidden');
                setTimeout(() => {
                    splashScreen.style.display = 'none';
                    mainViewport.classList.add('visible');
                }, 500);
            });
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a1a2a); 
            scene.fog = new THREE.Fog(0x0a1a2a, 20, 100);

            // Capture a desktop aspect ratio and size to use as a reference across viewports.
            // Use a fallback desktop size when the app is loaded on a small or mobile device
            const isSmallDevice = window.matchMedia('(max-width: 900px)').matches || ('ontouchstart' in window) || /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
            if (isSmallDevice) {
                DESKTOP_WIDTH = DEFAULT_DESKTOP.w; DESKTOP_HEIGHT = DEFAULT_DESKTOP.h;
            } else {
                DESKTOP_WIDTH = window.innerWidth; DESKTOP_HEIGHT = window.innerHeight;
            }
            DESKTOP_ASPECT = DESKTOP_WIDTH / DESKTOP_HEIGHT;
            camera = new THREE.PerspectiveCamera(60, DESKTOP_ASPECT, 0.1, 1000);
            camera.position.set(0, 10, -20);

            const container = document.getElementById('scene-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            // renderer size and camera aspect are set via resizeViewport() to preserve desktop aspect ratio
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0';
            labelRenderer.domElement.style.pointerEvents = 'none';
            container.appendChild(labelRenderer.domElement);

            // Ensure renderer and camera are sized to preserve desktop aspect ratio
            resizeViewport();
            updateUiScale();

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 10);
            controls.maxPolarAngle = Math.PI/2 - 0.05;
            controls.enableDamping = true;

            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(10, 30, -10);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.left = -50; sun.shadow.camera.right = 50;
            sun.shadow.camera.top = 50; sun.shadow.camera.bottom = -50;
            scene.add(sun);

            setupPhysics();
            createEnvironment();
            createMachine();
            createFieldMarkers(); 
            createPlayerMarker();

            setupUI();
            applyDrillSelection(); // Load defaults
            requestAnimationFrame(animate);
        }

        // --- v5.1 PHYSICS SETUP ---
        function setupPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, state.gravity, 0);
            world.allowSleep = true; 
            
            matGround = new CANNON.Material();
            matPitch = new CANNON.Material();
            matBall = new CANNON.Material();

            contactGrass = new CANNON.ContactMaterial(matGround, matBall, { friction: state.gFric, restitution: state.gRes });
            contactPitch = new CANNON.ContactMaterial(matPitch, matBall, { friction: state.pFric, restitution: state.pRes });
            world.addContactMaterial(contactGrass);
            world.addContactMaterial(contactPitch);
        }

        function updatePhysicsParams() {
            world.gravity.set(0, state.gravity, 0);
            contactGrass.friction = state.gFric; contactGrass.restitution = state.gRes;
            contactPitch.friction = state.pFric; contactPitch.restitution = state.pRes;
            balls.forEach(b => { b.body.wakeUp(); b.body.mass = state.mass; b.body.angularDamping = state.angDrag; b.body.updateMassProperties(); });
        }

        function createEnvironment() {
            const grassGeo = new THREE.PlaneGeometry(250, 250);
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x1b4d1b, roughness: 1 });
            const grass = new THREE.Mesh(grassGeo, grassMat);
            grass.rotation.x = -Math.PI / 2;
            grass.receiveShadow = true;
            scene.add(grass);
            grassMesh = grass;

            const grassBody = new CANNON.Body({ mass: 0, material: matGround, shape: new CANNON.Plane() });
            grassBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
            world.addBody(grassBody);

            const pitchGeo = new THREE.PlaneGeometry(3.6, 22);
            const pitchMat = new THREE.MeshStandardMaterial({ color: 0xd6c4a0, roughness: 0.8 });
            const pitch = new THREE.Mesh(pitchGeo, pitchMat);
            pitch.rotation.x = -Math.PI / 2;
            // Standard orientation: pitch center in front of keeper
            pitch.position.set(0, 0.01, 11);
            pitch.receiveShadow = true;
            scene.add(pitch);
            const pitchBody = new CANNON.Body({ mass: 0, material: matPitch });
            pitchBody.addShape(new CANNON.Box(new CANNON.Vec3(1.8, 11, 0.1)));
            pitchBody.position.set(0, -0.1, 11);
            pitchBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
            world.addBody(pitchBody);
        }

        function createFieldMarkers() {
            const centerZ = 11; 
            const c30 = new THREE.Mesh(new THREE.RingGeometry(27.3, 27.5, 128), new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true, side: THREE.DoubleSide }));
            c30.rotation.x = -Math.PI/2; c30.position.set(0, 0.02, centerZ); scene.add(c30);
            const bound = new THREE.Mesh(new THREE.RingGeometry(65, 66, 128), new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.8, side: THREE.DoubleSide }));
            bound.rotation.x = -Math.PI/2; bound.position.set(0, 0.02, centerZ); scene.add(bound);

            const labels = [
                { n: "Third Man", x: -25, z: 35 }, { n: "Fine Leg", x: 25, z: 35 }, { n: "Long Off", x: -15, z: -30 }, { n: "Long On", x: 15, z: -30 },
                { n: "Deep Point", x: -50, z: 22 }, { n: "Deep Square Leg", x: 50, z: 22 }, { n: "Point", x: -20, z: 22 }, { n: "Square Leg", x: 20, z: 22 },
                { n: "Cover", x: -15, z: 10 }, { n: "Mid Wicket", x: 15, z: 10 }, { n: "Mid Off", x: -8, z: 0 }, { n: "Mid On", x: 8, z: 0 },
                { n: "Slips", x: -3, z: 25 }, { n: "Keeper", x: 0, z: 24 }
            ];
            labels.forEach(p => {
                const cvs = document.createElement('canvas'); const ctx = cvs.getContext('2d'); cvs.width=256; cvs.height=64;
                ctx.fillStyle="rgba(0,0,0,0)"; ctx.fillRect(0,0,256,64); ctx.fillStyle="rgba(255,255,255,0.5)"; ctx.font="bold 35px Arial";
                ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(p.n, 128, 32);
                const tex = new THREE.CanvasTexture(cvs); const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(8, 2), mat); 
                mesh.rotation.x = -Math.PI/2; 
                mesh.position.set(p.x, 0.05, p.z); 
                scene.add(mesh);
            });
        }

        function createPlayerMarker() {
            const geo = new THREE.CylinderGeometry(0.4, 0.4, 1.8, 16);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0x444400 });
            playerMarker = new THREE.Mesh(geo, mat);
            playerMarker.position.set(0, 0.9, 20); playerMarker.visible = false; scene.add(playerMarker);
        }

        function onMouseMove(e) {
            if (!state.playerMode) return;
            // Convert client coordinates to normalized device coordinates relative to the renderer element
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(grassMesh);
            
            if (intersects.length > 0) {
                const pt = intersects[0].point;
                playerMarker.position.set(pt.x, 0.9, pt.z);

                // Pan: aim toward player relative to machine's world orientation
                const basePos = machineBase ? machineBase.position : new THREE.Vector3();
                const relX = pt.x - basePos.x;
                const relZ = pt.z - basePos.z;
                const worldYawDeg = THREE.MathUtils.radToDeg(Math.atan2(relX, relZ));
                const baseYawDeg = machineBase ? THREE.MathUtils.radToDeg(machineBase.rotation.y) : 0;
                const angleDeg = baseYawDeg - worldYawDeg;
                
                // Pan is usually not limited by drill in the same way, but let's clamp it if you want strict field constraints
                // For now, we allow full pan to track player, but launch will be clamped if needed.
                updateSliderOnly('inp-pan', 'pan', 'val-pan', angleDeg, 'Â°');

                const dist = Math.sqrt(relX*relX + relZ*relZ);
                
                // USE DRILL DEFAULTS
                const limits = state.limits;
                
                // Pick a default tilt from the drill (midpoint or default)
                let t = limits.tDef; 
                
                // Check if this tilt is within current limits (it should be)
                if(t < limits.tMin) t = limits.tMin;
                if(t > limits.tMax) t = limits.tMax;

                updateSliderOnly('inp-tilt', 'tilt', 'val-tilt', t, 'Â°');

                let spd;
                if(t > 0) {
                     // Calculate required speed for air shots based on drill's default tilt
                     const rad = THREE.MathUtils.degToRad(t);
                     const g = Math.abs(state.gravity);
                     const sin2t = Math.sin(2 * rad);
                     if(sin2t > 0.05) {
                         const v = Math.sqrt((dist * g) / sin2t);
                         spd = v * 3.6;
                     } else {
                         spd = (limits.sMin + limits.sMax) / 2;
                     }
                } else {
                    // Grounders: Use max speed for long range
                    spd = limits.sMax; 
                }

                // --- CRITICAL: CLAMP SPEED TO DRILL LIMITS ---
                // If player is too far, speed will cap at sMax.
                if(spd > limits.sMax) spd = limits.sMax; 
                if(spd < limits.sMin) spd = limits.sMin;
                
                updateSliderOnly('inp-speed', 'speed', 'val-speed', spd, ' km/h');
            }
        }

        function createMachine() {
            const matDark = new THREE.MeshStandardMaterial({ color: 0x222 });
            const matMetal = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.7, roughness: 0.3 });

            // Simple, practical base: low-profile platform with short feet and compact head
            machineBase = new THREE.Group();
            // Move machine to the opposite side of the pitch (behind the batsman end)
            machineBase.position.set(0, 0.12, 22);
            // Rotate base 180Â° so it faces back towards the keeper/pitch
            machineBase.rotation.y = Math.PI;
            scene.add(machineBase);

            // Base platform
            const basePlate = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.18, 0.8), matMetal);
            basePlate.position.y = 0; basePlate.receiveShadow = true; basePlate.castShadow = true; machineBase.add(basePlate);

            // Short feet (4 corners)
            const footGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.08, 12);
            const footOffsets = [ [0.48, -0.09, 0.28], [-0.48, -0.09, 0.28], [0.48, -0.09, -0.28], [-0.48, -0.09, -0.28] ];
            footOffsets.forEach(off => {
                const f = new THREE.Mesh(footGeo, matDark);
                f.position.set(off[0], off[1], off[2]); f.castShadow = true; machineBase.add(f);
            });

            // Small pillar to raise the head a little above the plate
            const pillar = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.18, 0.18), matDark);
            pillar.position.set(0, 0.12, 0); machineBase.add(pillar);

            // Connecting rod (thin cylinder) that links the pillar to the moving head
            const rodGeo = new THREE.CylinderGeometry(0.04, 0.04, 1.0, 12);
            machineRod = new THREE.Mesh(rodGeo, matMetal);
            machineRod.castShadow = true; machineRod.receiveShadow = true;
            machineRod.scale.set(1, 1.0, 1);
            // add rod to scene (we position/rotate it in world space each frame)
            scene.add(machineRod);

            // Create a swivel group positioned at the pillar top so only the head pans
            machineSwivel = new THREE.Group();
            // pillar top relative to machineBase: pillar.position.y (0.12) + half pillar height (0.09) = 0.21
            machineSwivel.position.set(0, 0.21, 0);
            machineBase.add(machineSwivel);

            // Compact head mounted on swivel (its local Y is relative to swivel pivot)
            machineHead = new THREE.Group();
            // Head local Y such that world Y ~= state.height + 0.12 (previous behavior)
            machineHead.position.set(0, state.height - 0.09, 0);
            machineSwivel.add(machineHead);
            const housing = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.32, 0.48), matDark); housing.castShadow = true; machineHead.add(housing);
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.36, 12), matDark);
            barrel.rotation.x = Math.PI/2; barrel.position.z = 0.32; machineHead.add(barrel);
        }

        function fireBall() {
            const rnd = (min, max) => Math.random() * (max - min) + min;
            let finalSpeed, finalTilt, finalPan;
            
            const limits = state.limits;

            if (state.drill === 'Custom') {
                // CUSTOM MODE: Use exact slider values, no randomization, no updates
                finalSpeed = state.speed;
                finalTilt = state.tilt;
                finalPan = state.pan;
            } else if (state.playerMode) {
                const pt = playerMarker.position;
                const basePos = machineBase ? machineBase.position : new THREE.Vector3();
                const relX = pt.x - basePos.x;
                const relZ = pt.z - basePos.z;
                const dist = Math.sqrt(relX*relX + relZ*relZ);
                const worldYawDeg = THREE.MathUtils.radToDeg(Math.atan2(relX, relZ));
                const baseYawDeg = machineBase ? THREE.MathUtils.radToDeg(machineBase.rotation.y) : 0;
                const basePan = baseYawDeg - worldYawDeg;
                
                // 1. Pan: Aim at player with slight error
                const err = state.error;
                finalPan = basePan + rnd(-err, err);

                // 2. Tilt: Select a random tilt strictly WITHIN Drill Limits
                let baseTilt = rnd(limits.tMin, limits.tMax);
                
                // 3. Speed: Calculate necessary speed for that tilt
                let baseSpeed;
                if (baseTilt > 0) {
                    // Ballistic Calculation: v = sqrt(d*g / sin(2*theta))
                    const g = Math.abs(state.gravity);
                    const rad = THREE.MathUtils.degToRad(baseTilt);
                    const sin2t = Math.sin(2 * rad);
                    
                    if(sin2t > 0.05) {
                        const v_ms = Math.sqrt((dist * g) / sin2t);
                        baseSpeed = v_ms * 3.6; // Convert to km/h
                    } else {
                        baseSpeed = limits.sDef; 
                    }
                } else {
                    // Grounder: Just pick random speed in limits
                    baseSpeed = rnd(limits.sMin, limits.sMax);
                }

                // 4. --- STRICT CLAMPING ---
                // Even if player is far, we MUST NOT exceed the drill's sMax
                if(baseSpeed < limits.sMin) baseSpeed = limits.sMin;
                if(baseSpeed > limits.sMax) baseSpeed = limits.sMax;

                // Apply error to calculated values
                finalTilt = baseTilt + rnd(-err*0.2, err*0.2);
                finalSpeed = baseSpeed + rnd(-err, err);

            } else {
                // DRILL MODE: Randomize within user limits
                finalSpeed = rnd(limits.sMin, limits.sMax);
                finalTilt = rnd(limits.tMin, limits.tMax);
                finalPan = rnd(limits.pMin, limits.pMax);
            }

            // Update Visual State (only if not in Custom mode)
            if (state.drill !== 'Custom') {
                updateSliderOnly('inp-speed', 'speed', 'val-speed', finalSpeed, ' km/h');
                updateSliderOnly('inp-tilt', 'tilt', 'val-tilt', finalTilt, 'Â°');
                updateSliderOnly('inp-pan', 'pan', 'val-pan', finalPan, 'Â°');
            }

            const vMag = finalSpeed * (1000/3600);
            // Use the actual machine head world transform so physics direction matches visuals,
            // no matter where the machine is placed on the field.
            const headWorldPos = new THREE.Vector3();
            const headWorldQuat = new THREE.Quaternion();
            machineHead.getWorldPosition(headWorldPos);
            machineHead.getWorldQuaternion(headWorldQuat);
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(headWorldQuat).normalize();
            const barrelFrontOffset = 0.5; // distance from head center to barrel exit
            const spawnPos = headWorldPos.clone().add(forward.clone().multiplyScalar(barrelFrontOffset));

            // v5.1 PHYSICS BODY
            const body = new CANNON.Body({
                mass: state.mass, shape: new CANNON.Sphere(0.072),
                position: new CANNON.Vec3(spawnPos.x, spawnPos.y, spawnPos.z),
                linearDamping: state.drag, angularDamping: state.angDrag, 
                material: matBall
            });
            body.velocity.set(forward.x * vMag, forward.y * vMag, forward.z * vMag);
            body.angularVelocity.set(-5, 0, 0); 
            body.sleepSpeedLimit = 0.5; body.sleepTimeLimit = 0.5;
            world.addBody(body);

            const geo = new THREE.SphereGeometry(0.072, 32, 32);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff3300, roughness: 0.4, emissive: 0x441100 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            
            const spriteMap = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/spark1.png');
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: spriteMap, color: 0xffaa00, transparent: true, blending: THREE.AdditiveBlending }));
            sprite.scale.set(0.6, 0.6, 0.6); mesh.add(sprite); scene.add(mesh);

            const trailGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(500 * 3);
            trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            trailGeo.setDrawRange(0, 0);
            const trailMat = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 1, opacity: 0.7, transparent: true });
            const trailLine = new THREE.Line(trailGeo, trailMat);
            scene.add(trailLine);

            const div = document.createElement('div'); div.className = 'ball-label'; div.textContent = '...';
            const label = new CSS2DObject(div);
            // Initialize label at ball world position and place it slightly above the ball
            label.position.copy(mesh.position);
            label.position.y += 0.2; // keep the label slightly above the ball
            // Add label directly to scene (so it doesn't inherit the ball's rotation)
            scene.add(label);

            // attach per-ball graph buffer for runtime sampling
            // Reset lastGraphData now that a new ball is being fired (start fresh)
            lastGraphData = null;
            const ballObj = { mesh, body, trailLine, label, trailPos: positions, trailIdx: 0, created: Date.now(), isDead: false, maxH: 0, graphData: [] };
            balls.push(ballObj);
        }

        function removeBall(b) {
            b.isDead = true;
            world.removeBody(b.body);
            scene.remove(b.mesh);
            scene.remove(b.trailLine);
            b.trailLine.geometry.dispose();
            if (b.label) { scene.remove(b.label); if (b.label.element && b.label.element.parentNode) b.label.element.parentNode.removeChild(b.label.element); }
            // Preserve last graph data so the graph remains on screen after the ball stops
            if (b.graphData && b.graphData.length > 0) lastGraphData = b.graphData.slice();
            balls = balls.filter(ball => ball !== b);
        }

        // Apply drill defaults + INSTANTLY ROTATE MACHINE
        function applyDrillSelection() {
            if (state.drill === 'Custom') {
                // Custom mode: Enable sliders and set wide limits
                state.limits = { sMin: 40, sMax: 160, sDef: 80, tMin: -10, tMax: 80, tDef: 10, pMin: -45, pMax: 45, pDef: 0 };
                
                document.getElementById('min-speed').value = 40; document.getElementById('max-speed').value = 160;
                document.getElementById('min-tilt').value = -10;  document.getElementById('max-tilt').value = 80;
                document.getElementById('min-pan').value = -45;   document.getElementById('max-pan').value = 45;

                // Enable sliders for custom mode
                document.getElementById('inp-speed').disabled = false;
                document.getElementById('inp-tilt').disabled = false;
                document.getElementById('inp-pan').disabled = false;
            } else {
                const def = defaultDrills[state.drill];
                state.limits = { ...def };
                
                document.getElementById('min-speed').value = def.sMin; document.getElementById('max-speed').value = def.sMax;
                document.getElementById('min-tilt').value = def.tMin;  document.getElementById('max-tilt').value = def.tMax;
                document.getElementById('min-pan').value = def.pMin;   document.getElementById('max-pan').value = def.pMax;

                // Instant Visual Feedback
                updateSliderOnly('inp-speed', 'speed', 'val-speed', def.sDef, ' km/h');
                updateSliderOnly('inp-tilt', 'tilt', 'val-tilt', def.tDef, 'Â°');
                updateSliderOnly('inp-pan', 'pan', 'val-pan', def.pDef, 'Â°');

                // Disable sliders for non-custom modes
                document.getElementById('inp-speed').disabled = true;
                document.getElementById('inp-tilt').disabled = true;
                document.getElementById('inp-pan').disabled = true;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            world.step(1/60); // v5.1 Physics Step

            // Keep base fixed; pan only rotates the swivel (visual head yaw)
            if (machineSwivel) machineSwivel.rotation.y = THREE.MathUtils.lerp(machineSwivel.rotation.y, THREE.MathUtils.degToRad(-state.pan), 0.1);
            // Tilt (pitch) applies to the head local rotation.x
            if (machineHead) machineHead.rotation.x = THREE.MathUtils.lerp(machineHead.rotation.x, THREE.MathUtils.degToRad(-state.tilt), 0.1);
            // Smoothly animate the head's local Y (distance from swivel) to follow state.height
            if (machineHead) machineHead.position.y = THREE.MathUtils.lerp(machineHead.position.y, state.height - 0.09, 0.1);

            // Update connecting rod to visually link pillar top to the moving head in world space
            if (machineRod && machineHead && machineBase) {
                // pillar top world position
                const pillarTopLocal = new THREE.Vector3(0, 0.21, 0);
                const pillarTopWorld = pillarTopLocal.clone(); machineBase.localToWorld(pillarTopWorld);
                // head world position
                const headWorld = new THREE.Vector3(); machineHead.getWorldPosition(headWorld);

                // vector from pillar top to head
                const v = new THREE.Vector3().subVectors(headWorld, pillarTopWorld);
                const length = Math.max(0.05, v.length());

                // position rod midpoint
                const mid = new THREE.Vector3().addVectors(pillarTopWorld, headWorld).multiplyScalar(0.5);
                machineRod.position.copy(mid);

                // align rod's Y axis to vector v
                const up = new THREE.Vector3(0, 1, 0);
                const q = new THREE.Quaternion().setFromUnitVectors(up, v.clone().normalize());
                machineRod.quaternion.copy(q);

                // scale rod to match length (original cylinder height = 1.0, so scale.y = length)
                machineRod.scale.set(1, length, 1);
            }

            balls.forEach(b => {
                if (b.isDead) return;
                b.mesh.position.copy(b.body.position);
                b.mesh.quaternion.copy(b.body.quaternion);

                const speed = b.body.velocity.length();
                const dist = Math.sqrt(b.mesh.position.x**2 + b.mesh.position.z**2);
                if(b.mesh.position.y > b.maxH) b.maxH = b.mesh.position.y;

                if (b.label && b.label.element) {
                    if (speed > 1) { b.label.element.textContent = `${(speed*3.6).toFixed(0)} km/h`; b.label.element.style.color = '#ffff00'; } 
                    else { b.label.element.textContent = `${dist.toFixed(1)}m`; b.label.element.style.color = '#00ff00'; }
                }

                // Stabilize the label: keep the label near the ball's world position and slightly above it
                if (b.label) {
                    b.label.position.copy(b.mesh.position);
                    b.label.position.y += 0.28;
                    // Ensure label faces camera and stays easy to read
                    if (camera) b.label.quaternion.copy(camera.quaternion);
                }

                // Always append graph data for the ball (trim to last GRAPH_MAX_SECONDS)
                if (b.graphData) {
                    const ts = (Date.now() - b.created) / 1000.0;
                    // Keep full buffer (do NOT rotate/truncate) so 0..GRAPH_MAX_SECONDS from the start always maps to the initial time window
                    b.graphData.push({ t: ts, speed: speed * 3.6, y: b.mesh.position.y, dist: dist, ang: b.body.angularVelocity.length() });
                }

                if (b === balls[balls.length-1]) {
                    document.getElementById('stat-vel').textContent = (speed*3.6).toFixed(1) + ' km/h';
                    document.getElementById('stat-dist').textContent = dist.toFixed(1) + ' m';
                    document.getElementById('stat-height').textContent = b.maxH.toFixed(1) + ' m';
                }

                if (b.trailIdx < 500 && speed > 0.1) {
                    const i = b.trailIdx * 3;
                    b.trailPos[i] = b.mesh.position.x; b.trailPos[i+1] = b.mesh.position.y; b.trailPos[i+2] = b.mesh.position.z;
                    b.trailIdx++; b.trailLine.geometry.setDrawRange(0, b.trailIdx); b.trailLine.geometry.attributes.position.needsUpdate = true;
                }

                if (b.body.sleepState === CANNON.Body.SLEEPING || b.mesh.position.y < -1) {
                    document.getElementById('stat-status').textContent = "Ball Stopped"; removeBall(b);
                } else { document.getElementById('stat-status').textContent = "Active"; }
            });

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
            if (graphVisible) renderGraph();
        }

        function updateSliderOnly(id, key, dispId, val, unit='') {
            state[key] = parseFloat(val);
            document.getElementById(id).value = state[key];
            if(dispId) document.getElementById(dispId).textContent = (Math.round(state[key]*100)/100) + unit;
        }

        function updatePhysicsInput(id, key, dispId, val, unit='') {
            updateSliderOnly(id, key, dispId, val, unit);
        }

        // --- LIVE GRAPH HELPERS ---
        function clampPanelToWindow() {
            if (!graphPanel) return;
            const vp = document.getElementById('viewport-inner');
            const parentW = vp ? vp.clientWidth : window.innerWidth; const parentH = vp ? vp.clientHeight : window.innerHeight;
            const w = graphPanel.clientWidth; const h = graphPanel.clientHeight;
            let l = graphPanel.offsetLeft; let t = graphPanel.offsetTop;
            const leftLimit = 6; const rightLimit = Math.max(leftLimit, parentW - w - 6); const topLimit = 6; const bottomLimit = Math.max(topLimit, parentH - h - 6);
            if (l < leftLimit) l = leftLimit; if (l > rightLimit) l = rightLimit;
            if (t < topLimit) t = topLimit; if (t > bottomLimit) t = bottomLimit;
            graphPanel.style.left = l + 'px'; graphPanel.style.top = t + 'px'; graphPanel.style.right = 'auto'; graphPanel.style.bottom = 'auto';
        }
        function resizeGraphCanvas() {
            if (!graphCanvas) return;
            const dpr = window.devicePixelRatio || 1;
            graphCanvas.width = Math.floor(graphCanvas.clientWidth * dpr);
            graphCanvas.height = Math.floor(graphCanvas.clientHeight * dpr);
            if (graphCtx) graphCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        function createGraphPanel() {
            graphPanel = document.getElementById('graph-panel');
            graphCanvas = document.getElementById('graph-canvas');
            graphCtx = graphCanvas.getContext('2d');
            const legend = document.getElementById('graph-legend');
            if (legend) {
                // static color legend with a live-value container to the right
                legend.innerHTML = `
                    <div class="legend-list">
                        <div class="legend-item"><span class="legend-swatch" style="background:rgba(255,145,0,0.95)"></span>Speed (km/h)</div>
                        <div class="legend-item"><span class="legend-swatch" style="background:rgba(30,144,255,0.95)"></span>Height (m)</div>
                        <div class="legend-item"><span class="legend-swatch" style="background:rgba(0,255,128,0.95)"></span>Dist (m)</div>
                        <div class="legend-item"><span class="legend-swatch" style="background:rgba(255,51,102,0.95)"></span>Spin</div>
                    </div>
                    <div class="legend-live" id="graph-legend-live">--</div>
                `;
            }
            // handle high DPI and initial sizing
            resizeGraphCanvas();

            // Drag & Resize handlers
            const dragHandle = graphPanel.querySelector('.graph-drag-handle');
            const resizer = graphPanel.querySelector('.graph-resizer');
            let isDragging = false, dragStart = {x:0,y:0}, panelStart = {left:0,top:0};
            let isResizing = false, resizeStart = {x:0,y:0,width:0,height:0}, aspect = graphPanel.clientWidth / graphPanel.clientHeight;

            const clampPanelToWindow = () => {
                const vp = document.getElementById('viewport-inner');
                const parentW = vp ? vp.clientWidth : window.innerWidth; const parentH = vp ? vp.clientHeight : window.innerHeight;
                const w = graphPanel.clientWidth; const h = graphPanel.clientHeight;
                let l = graphPanel.offsetLeft; let t = graphPanel.offsetTop;
                const leftLimit = 6; const rightLimit = Math.max(leftLimit, parentW - w - 6); const topLimit = 6; const bottomLimit = Math.max(topLimit, parentH - h - 6);
                if (l < leftLimit) l = leftLimit; if (l > rightLimit) l = rightLimit;
                if (t < topLimit) t = topLimit; if (t > bottomLimit) t = bottomLimit;
                graphPanel.style.left = l + 'px'; graphPanel.style.top = t + 'px'; graphPanel.style.right = 'auto'; graphPanel.style.bottom = 'auto';
            };

            function startDrag(e) { e.preventDefault(); dragHandle.setPointerCapture(e.pointerId); isDragging = true; dragStart.x = e.clientX; dragStart.y = e.clientY; // Use unscaled offsets for start position (CSS left/top values)
                panelStart.left = graphPanel.offsetLeft; panelStart.top = graphPanel.offsetTop; }
            function onDrag(e) { if(!isDragging) return; const dx = e.clientX - dragStart.x; const dy = e.clientY - dragStart.y; const vp = document.getElementById('viewport-inner'); const vpRect = vp ? vp.getBoundingClientRect() : null; const scale = (DESKTOP_WIDTH && vp) ? (vpRect.width / DESKTOP_WIDTH) : 1; // compute unscaled delta
                const dxUnscaled = dx / scale; const dyUnscaled = dy / scale; const parentWidth = vp ? vp.clientWidth : window.innerWidth; const parentHeight = vp ? vp.clientHeight : window.innerHeight; const leftLimit = 6; const rightLimit = Math.max(leftLimit, parentWidth - graphPanel.clientWidth - 6); const topLimit = 6; const bottomLimit = Math.max(topLimit, parentHeight - graphPanel.clientHeight - 6); const newLeft = Math.max(leftLimit, Math.min(rightLimit, Math.round(panelStart.left + dxUnscaled))); const newTop = Math.max(topLimit, Math.min(bottomLimit, Math.round(panelStart.top + dyUnscaled))); graphPanel.style.left = newLeft + 'px'; graphPanel.style.top = newTop + 'px'; }
            function endDrag(e) { try { dragHandle.releasePointerCapture(e.pointerId); } catch(_){} isDragging=false; }

            function startResize(e) { e.preventDefault(); resizer.setPointerCapture(e.pointerId); isResizing = true; resizeStart.x = e.clientX; resizeStart.y = e.clientY; resizeStart.width = graphPanel.clientWidth; resizeStart.height = graphPanel.clientHeight; aspect = resizeStart.width / resizeStart.height; }
            function onResize(e) { if(!isResizing) return; const dx = e.clientX - resizeStart.x; const vp = document.getElementById('viewport-inner'); const vpRect = vp ? vp.getBoundingClientRect() : null; const scale = (DESKTOP_WIDTH && vpRect) ? (vpRect.width / DESKTOP_WIDTH) : 1; let newWidth = Math.max(240, Math.round(resizeStart.width + dx / scale)); // min width (in unscaled units)
                let newHeight = Math.max(120, Math.round(newWidth / aspect)); // maintain aspect
                // limit to viewport-inner size in unscaled units
                const rect = graphPanel.getBoundingClientRect(); const left = graphPanel.offsetLeft; const parentW = vp ? vp.clientWidth : window.innerWidth; const parentH = vp ? vp.clientHeight : window.innerHeight; const maxW = Math.max(240, parentW - left - 12); const maxH = Math.max(120, parentH - graphPanel.offsetTop - 12);
                if(newWidth > maxW) { newWidth = maxW; newHeight = Math.max(120, Math.round(newWidth / aspect)); }
                if(newHeight > maxH) { newHeight = maxH; newWidth = Math.max(240, Math.round(newHeight * aspect)); }
                graphPanel.style.width = newWidth + 'px'; graphPanel.style.height = newHeight + 'px'; resizeGraphCanvas(); }
            function endResize(e) { try { resizer.releasePointerCapture(e.pointerId); } catch(_){} isResizing=false; }

            if (dragHandle) { dragHandle.addEventListener('pointerdown', startDrag); window.addEventListener('pointermove', onDrag); window.addEventListener('pointerup', endDrag); }
            if (resizer) { resizer.addEventListener('pointerdown', startResize); window.addEventListener('pointermove', onResize); window.addEventListener('pointerup', endResize); }
        }

        function toggleGraphPanel() {
            graphVisible = !graphVisible;
            if (graphPanel) graphPanel.style.display = graphVisible ? 'block' : 'none';
            if (!graphVisible) {
                // optional: clear the canvas when hidden
                if (graphCtx) { graphCtx.clearRect(0,0,graphCanvas.width, graphCanvas.height); }
            } else {
                // compute sizes and transform when panel becomes visible
                if (graphCanvas) {
                    const dpr = window.devicePixelRatio || 1;
                    graphCanvas.width = Math.floor(graphCanvas.clientWidth * dpr);
                    graphCanvas.height = Math.floor(graphCanvas.clientHeight * dpr);
                    // switch to CSS pixels coordinates (scale by dpr)
                    if (graphCtx) graphCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
                }
                // Force a render of the graph immediately after showing it
                renderGraph();
                if (clampPanelToWindow) clampPanelToWindow();
            }
        }

        function clearGraphData() {
            balls.forEach(b => { if (b.graphData) b.graphData = []; });
            lastGraphData = null;
            if (graphCtx) graphCtx.clearRect(0,0,graphCanvas.width, graphCanvas.height);
        }

        function renderGraph() {
            if (!graphCanvas || !graphCtx) return;
            // pick latest ball with graph data or the last ball
            const b = balls.length ? balls[balls.length - 1] : (lastGraphData ? { graphData: lastGraphData } : null);
            if (!b || !b.graphData || b.graphData.length === 0) {
                graphCtx.clearRect(0,0,graphCanvas.width, graphCanvas.height);
                return;
            }
            const data = b.graphData;
            const dpr = window.devicePixelRatio || 1;
            const w = graphCanvas.width / dpr; const h = graphCanvas.height / dpr;
            // Margins to keep axes and labels away from the plotting area
            const marginLeft = 48; const marginRight = 12; const marginTop = 12; const marginBottom = 26;
            const innerW = Math.max(16, w - marginLeft - marginRight);
            const innerH = Math.max(16, h - marginTop - marginBottom);
            graphCtx.clearRect(0,0,w,h);
            // draw grid and axes
            graphCtx.strokeStyle = 'rgba(255,255,255,0.16)'; graphCtx.lineWidth = 1;
            for (let i=0;i<=4;i++) {
                const y = Math.round(marginTop + innerH * (i/4));
                graphCtx.beginPath(); graphCtx.moveTo(marginLeft, y); graphCtx.lineTo(marginLeft + innerW, y); graphCtx.stroke();
            }
            // clear left area for y-labels so grid lines don't overlap labels
            graphCtx.clearRect(0, 0, marginLeft, h);
            // compute fixed time range: from 0 to GRAPH_MAX_SECONDS (do not rescale)
            const tmin = 0; const tmax = GRAPH_MAX_SECONDS;
            const xForT = t => marginLeft + ((t - tmin) / (tmax - tmin || 1)) * innerW;
            // fixed Y axis: 0..160 (user requested). All metrics are plotted within this fixed scale
            const Y_MAX = 160;
            const yForVal = (val) => marginTop + innerH - (Math.min(val, Y_MAX) / Y_MAX) * innerH;

            // helpers to draw series
            const drawSeries = (key, color, maxVal) => {
                graphCtx.beginPath(); graphCtx.strokeStyle = color; graphCtx.lineWidth = 2; graphCtx.lineJoin = 'round'; let started=false;
                data.forEach(pt => { if (pt.t < tmin || pt.t > tmax) return; const x = xForT(pt.t); const y = yForVal(pt[key], maxVal); if (!started) { graphCtx.moveTo(x,y); started=true; } else graphCtx.lineTo(x,y); });
                graphCtx.stroke();
            };

            // draw thicker, semi-opaque lines for better visibility; use fixed Y_MAX scale
            drawSeries('speed', 'rgba(255,145,0,0.95)', Y_MAX);
            drawSeries('y', 'rgba(30,144,255,0.95)', Y_MAX);
            drawSeries('dist', 'rgba(0,255,128,0.95)', Y_MAX);
            drawSeries('ang', 'rgba(255,51,102,0.95)', Y_MAX);

            // draw x-axis time ticks and labels (fixed 0..GRAPH_MAX_SECONDS)
            graphCtx.fillStyle = 'rgba(255,255,255,0.7)'; graphCtx.font = '11px monospace'; graphCtx.textAlign = 'center';
            // draw more frequent time markers (every 2 seconds)
            const tickSpacing = 2; const ticks = Math.floor((tmax - tmin) / tickSpacing) + 1;
            for (let i=0;i<ticks;i++) {
                const tt = tmin + i * tickSpacing; const tx = xForT(tt);
                graphCtx.beginPath(); graphCtx.strokeStyle = 'rgba(255,255,255,0.08)'; graphCtx.moveTo(tx, marginTop + innerH + 2); graphCtx.lineTo(tx, marginTop + innerH + 8); graphCtx.stroke();
                graphCtx.fillText(tt.toFixed(0) + 's', tx, marginTop + innerH + 18);
            }

            // draw y-axis ticks & labels (0..Y_MAX)
            graphCtx.textAlign = 'right'; graphCtx.fillStyle = 'rgba(255,255,255,0.8)';
            const yTicks = 5;
            for (let i=0;i<yTicks;i++) {
                const val = Math.round(i * (Y_MAX / (yTicks-1)));
                const y = Math.round(marginTop + innerH - (val / Y_MAX) * innerH);
                graphCtx.beginPath(); graphCtx.moveTo(36, y); graphCtx.lineTo(42, y); graphCtx.stroke();
                graphCtx.fillText(val.toString(), 34, y+3);
            }
            // draw Y axis label
            graphCtx.save(); graphCtx.translate(8, h/2); graphCtx.rotate(-Math.PI/2); graphCtx.textAlign = 'center'; graphCtx.fillText('Value (0 - ' + Y_MAX + ')', 0, 0); graphCtx.restore();

            // draw current values next to legend (latest sample within the 0..GRAPH_MAX_SECONDS window)
            let last = data.filter(pt=>pt.t >= tmin && pt.t <= tmax).slice(-1)[0];
            if (!last) last = data[data.length-1];
            const legendLive = document.getElementById('graph-legend-live');
            if (legendLive && last) {
                legendLive.innerHTML = `<span style="color:#ff9100">${Math.round(last.speed)} km/h</span>&nbsp;&nbsp;<span style="color:#1e90ff">${last.y.toFixed(2)} m</span>&nbsp;&nbsp;<span style="color:#00ff80">${last.dist.toFixed(2)} m</span>&nbsp;&nbsp;<span style="color:#ff3366">${last.ang.toFixed(2)}</span>`;
            }
        }

        function setupUI() {
            const bind = (id, key, disp, unit) => {
                document.getElementById(id).addEventListener('input', e => updateSliderOnly(id, key, disp, e.target.value, unit));
            };
            bind('inp-speed', 'speed', 'val-speed', ' km/h');
            bind('inp-tilt', 'tilt', 'val-tilt', 'Â°');
            bind('inp-pan', 'pan', 'val-pan', 'Â°');
            bind('inp-height', 'height', 'val-height', ' m'); 
            bind('inp-error', 'error', 'val-error', '');

            // Bind Limit Inputs
            const bindLimit = (id, key) => {
                document.getElementById(id).addEventListener('change', e => { state.limits[key] = parseFloat(e.target.value); });
            };
            bindLimit('min-speed', 'sMin'); bindLimit('max-speed', 'sMax');
            bindLimit('min-tilt', 'tMin'); bindLimit('max-tilt', 'tMax');
            bindLimit('min-pan', 'pMin'); bindLimit('max-pan', 'pMax');

            document.getElementById('player-mode-toggle').addEventListener('change', e => {
                state.playerMode = e.target.checked;
                if(playerMarker) playerMarker.visible = state.playerMode;
                if(state.playerMode) window.addEventListener('mousemove', onMouseMove);
                else window.removeEventListener('mousemove', onMouseMove);
            });

            document.getElementById('drill-select').addEventListener('change', e => {
                state.drill = e.target.value;
                applyDrillSelection();
            });
            document.getElementById('btn-reset-drill').addEventListener('click', () => applyDrillSelection());

            document.getElementById('env-select').addEventListener('change', e => {
                state.env = e.target.value;
                const p = envPresets[state.env];
                state.pRes = p.pRes; state.pFric = p.pFric; state.gRes = p.gRes; state.gFric = p.gFric;
                updatePhysicsInput('phy-pres', 'pRes', 'disp-pres', p.pRes); updatePhysicsInput('phy-pfric', 'pFric', 'disp-pfric', p.pFric);
                updatePhysicsInput('phy-gres', 'gRes', 'disp-gres', p.gRes); updatePhysicsInput('phy-gfric', 'gFric', 'disp-gfric', p.gFric);
                updatePhysicsParams();
            });

            document.getElementById('fire-btn').addEventListener('click', () => { fireBall(); document.getElementById('fire-btn').blur(); });
            window.addEventListener('keydown', e => { if(e.code === 'Space') { e.preventDefault(); fireBall(); } });
            window.addEventListener('resize', () => {
                // Keep initial desktop aspect ratio across devices
                resizeViewport();
                updateUiScale();
                // adjust graph canvas
                if (graphCanvas) {
                    const dpr = window.devicePixelRatio || 1; graphCanvas.width = Math.floor(graphCanvas.clientWidth * dpr); graphCanvas.height = Math.floor(graphCanvas.clientHeight * dpr);
                    if (graphCtx) graphCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
                }
            });
            // Handle device orientation changes (mobile)
            window.addEventListener('orientationchange', () => { setTimeout(() => { resizeViewport(); updateUiScale(); if (graphPanel) clampPanelToWindow(); if (graphCanvas) resizeGraphCanvas(); }, 120); });

            const bindPhy = (id, key, disp) => {
                document.getElementById(id).addEventListener('input', e => { updatePhysicsInput(id, key, disp, e.target.value); updatePhysicsParams(); });
            };
            bindPhy('phy-gravity', 'gravity', 'disp-gravity'); bindPhy('phy-mass', 'mass', 'disp-mass');
            bindPhy('phy-drag', 'drag', 'disp-drag'); bindPhy('phy-ang', 'angDrag', 'disp-ang');
            bindPhy('phy-pres', 'pRes', 'disp-pres'); bindPhy('phy-pfric', 'pFric', 'disp-pfric');
            bindPhy('phy-gres', 'gRes', 'disp-gres'); bindPhy('phy-gfric', 'gFric', 'disp-gfric');

            document.getElementById('reset-phy-btn').addEventListener('click', () => {
                updatePhysicsInput('phy-gravity', 'gravity', 'disp-gravity', -9.81); updatePhysicsInput('phy-mass', 'mass', 'disp-mass', 0.16);
                updatePhysicsInput('phy-drag', 'drag', 'disp-drag', 0.3); updatePhysicsInput('phy-ang', 'angDrag', 'disp-ang', 0.4);
                document.getElementById('env-select').value = 'standard'; state.env = 'standard'; const p = envPresets.standard;
                updatePhysicsInput('phy-pres', 'pRes', 'disp-pres', p.pRes); updatePhysicsInput('phy-pfric', 'pFric', 'disp-pfric', p.pFric);
                updatePhysicsInput('phy-gres', 'gRes', 'disp-gres', p.gRes); updatePhysicsInput('phy-gfric', 'gFric', 'disp-gfric', p.gFric);
                updatePhysicsParams();
            });

            applyDrillSelection();
            // prepare the graph panel and event handlers
            createGraphPanel();
            // sizing
            if (graphCanvas) { const dpr = window.devicePixelRatio || 1; graphCanvas.width = Math.floor(graphCanvas.clientWidth * dpr); graphCanvas.height = Math.floor(graphCanvas.clientHeight * dpr); if (graphCtx) graphCtx.setTransform(dpr, 0, 0, dpr, 0, 0); }
            const btn = document.getElementById('btn-toggle-graph'); if (btn) btn.addEventListener('click', toggleGraphPanel);
            const btnc = document.getElementById('btn-clear-graphs'); if (btnc) btnc.addEventListener('click', clearGraphData);
        }

        // Initialize splash screen first
        initSplashScreen();
        
        // Initialize simulator (but it will be hidden until splash is dismissed)
        init();
    </script>
</body>
</html>